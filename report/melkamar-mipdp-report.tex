\documentclass[czech]{article}
\usepackage{listings}
%\documentstyle[epsf,epic,eepic,eepicemu]{article} \oddsidemargin=-5mm

\usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8
\oddsidemargin=-5mm
\evensidemargin=-5mm\marginparwidth=.08in \marginparsep=.01in
\marginparpush=5pt\topmargin=-15mm\headheight=12pt
%\headsep=25pt\footheight=12pt \footskip=30pt\textheight=25cm
\textwidth=17cm\columnsep=2mm
\columnseprule=1pt\parindent=15pt\parskip=2pt

\begin{document}
\begin{center}
\bf Semestrální projekt MI-PDP 2016/2017:\\[5mm]
    Paralelní algoritmus pro řešení problému maximálního bipartitiního podgrafu\\[5mm] 
       Martin Melka\\[2mm]
magisterské studium, FIT ČVUT, Thákurova 9, 160 00 Praha 6\\[2mm]
\today
\end{center}

\section{Definice problému a popis sekvenčního algoritmu}

\subsection{Definice problému}
Řešení problému maximálního bipartitního podgrafu (MBG) znamená nalézt takový podgraf H daného grafu G, který je bipartitní a jeho počet hran je maximální, tj. neexistuje žádný další bipartitní podgraf grafu G, který by měl větší počet hran než H. Množinu hran grafu H označme F.

Graf je bipartitní právě tehdy, když lze všechny jeho uzly obarvit dvěma barvami.

Jelikož je vstupní graf souvislý, lze určit spodní mez počtu hran řešení. Tou bude $|F|=n-1$, kde $n$ je počet hran grafu. Toto řešení je dáno tím, že pro každý souvislý graf lze najít kostru, tedy takový podgraf, který je strom. Kostru pak stačí "zakořenit", uzly uspořádat do úrovní, jak je u stromů zvykem, a každou úroveň obarvit jinou barvou než tu předchozí.

\subsection{Formát vstupních dat}
Formát vstupních dat je daný zadáním:
\begin{itemize}
	\item Na prvním řádku je číslo $n$, určující počet hran grafu G
	\item Na následujících $n$ řádcích je vždy $n$ číslic $0$ nebo $1$, které reprezentují matici sousednosti grafu -- $1$ znamená, že odpovídající uzly mezi sebou mají hranu, $0$ že nemají.
\end{itemize}

\subsection{Formát výstupních dat}
Formát výstupních dat má následující strukturu:

\begin{verbatim}
Best bipartite graph edge count:
================
==   25 edges ==
================
Bipartite subsets:
0) 0  4  6  7  9  14  1  11  3
1) 2  8  10  12  13  15  5

Edges in bipartite subgraph:
0 <-> 2
0 <-> 8
(...)


Computation time:
13.0867
\end{verbatim}

\noindent Kde: 
\begin{itemize}
	\item Ohraničená hodnota udává počet hran nalezeného grafu,
	\item množiny čísel pod \texttt{Bipartite subsets} ukazují, do které ze dvou množin ten který uzel patří (tj. kterými barvami jsou uzly obarveny),
	\item seznam dvojic čísel udává, mezi kterými uzly jsou ve výsledném grafu hrany,
	\item a nakonec je uveden čas v sekundách, jež byl potřeba pro dokončení výpočtu.
\end{itemize}
\subsection{Popis sekvenčního algoritmu}
Algoritmus řešící problém MBG sekvenčně využívá prohledávání do hloubky, případně do šířky. Detailní popis těchto metod není předmětem tohoto předmětu, jelikož už byly popsány dříve (BI-PA2, BI-ZUM, BI-EFA, BI-GRA).

K reprezentaci uzlů prohledávaného stavového prostoru jsem zvolil matici sousednosti. Z hlediska implementace to znamená to, že každý stav je reprezentován třídou \texttt{Graph}, jež si uchovává vlastní kopii dvourozměrného pole -- matici sousednosti. Kromě toho má některé pomocné metody, například pro ověření, zda je tento graf bipartitní, spojitý, či nespojitý (metoda vrací hodnoty $1$, $0$, resp. $-1$ jako příznak těchto vlastností).

\subsubsection{Generování stavů}
V každém kroku DFS je nutné vygenerovat potomky řešeného stavu (grafu), které se vloží do zásobníku a budou dále zpracovávat. Algoritmus, kterým jsem se rozhodl tyto sousedy-potomky generovat zajišťuje, že množina vygenerovaných podgrafů bude disjunktní -- tedy že žádné dva grafy nebudou totožné, což by v případě jednoduchého odebírání hran nastávalo.

Algoritmus generování funguje tak, že ze zadaného grafu postupně odebírá hrany, čímž generuje podgrafy. Hrany jsou odebírány následujícím způsobem -- každý graf má indexy \texttt{startI} a \texttt{startJ} do matice sousednosti. Ty určují, od které pozice v matici dále budou odebírány hrany (tj. měněny jedičky na nuly). Na předchozí hrany algoritmus nesmí sahat.

Vygenerování množiny potomků stavu s grafem \texttt{G} pak znamená:
\begin{lstlisting}[tabsize=2,language=python]
	given graph G:
	
	neighbors = []
	foreach (i,j)>(startI,startJ):
		if edge(i,j) is present:
			new_graph = G.remove_edge(i,j)
			new_graph.startI = i
			new_graph.startJ = j
			neighbors.append(new_graph)
			
\end{lstlisting}
Tímto způsobem generuji stavy, které může mít dále smysl prohledávat.


\subsubsection{Ořezávání stavového prostoru}
Před samotným zpracováním vygenerovaných stavů je vhodné provést kontrolu, zda to má vůbec smysl:
\begin{itemize}
	\item Pokud je graf bipartitní, nemá smysl prohledávat jeho potomky -- budou mít určitě menší počet hran a tento graf bude tedy zaručeně lepší.
	\item Pokud má graf stejný nebo menší počet hran než dosud nejlepší nalezený graf, nemá smysl ho dále prohledávat.
	\item Pokud je vygenerovaný graf nespojitý, nemá smysl se s ním dále zabývat - zajímají mě pouze spojité grafy. Test spojitosti provádím v rámci testu bipartity, viz popis reprezentace uzlu výše.
	\item Pokud má graf méně hran než $|V|-1$, nemá smysl se s ním zabývat, jelikož toto je spodní mez řešení.
\end{itemize}

\subsection{Naměřené časy}
Časy naměřené na vzorových datech na lokálním stroji (frekvence CPU 2.4GHz) jsou následující:

\begin{itemize}
	\item \texttt{graph10\_5.txt} -- 1020 ms
	\item \texttt{graph17\_3.txt} -- 10 ms
	\item \texttt{graph20\_3.txt} -- 120 ms
	\item \texttt{graph25\_3.txt} -- 130 ms
	\item \texttt{graph14\_4.txt} -- 1650 ms
\end{itemize}

\section{Popis paralelního algoritmu a jeho implementace v OpenMP}

Paralelní algoritmus v OpenMP, tj. řešení se sdílenou pamětí, jsem řešil dvěma způsoby -- pomocí task paralelismu a datového paralelismu.

\textit{Task paralelismus} jsem řešil jednoduše vytvářením nového \texttt{OMP Task} při každém rekurzivním volání DFS funkce. Až na toto tvoření tasků a uzamykání aktualizace nejlepšího řešení do kritické sekce, bylo toto řešení totožné se sekvenčním.

\textit{Datový paralelismus} byl implementačně o něco náročnější než \textit{Task paralelismus}. Pro jeho korektní běh bylo nejprve nutné vygenerovat dostatečně velkou množinu počátečních (disjunktních) stavů, nad kterou poté budou OpenMP vlákna iterovat. Generování počátečních stavů jsem extrahoval do samostatné funkce, která ale vnitřně funguje velmi podobně běžnému BFS algoritmu. Prohledávání probíhá stejně jako u "ostrého" řešení s tím, že ve chvíli, kdy velikost fronty grafů čekajících na zpracování odpovídá zadanému parametru, algoritmus na její konec vloží nedozpracovaný graf (abych nepřišel o žádný ze stavů) a celou frontu vrátí jako výsledek funkce. Nad touto frontou grafů pak standardně pomocí \texttt{\#pragma omp parallel for} spustím požadovaný počet vláken.

Tím, že vlákna mají disjunktní množinu počátečních stavů, které jsou na sobě nezávislé, nemusí na sebe nijak čekat (vyjma kritické sekce při nalezení nového maxima).

Počet generovaných stavů jsem empiricky stanovil na 200násobek počtu vláken, ale ideální hodnota tohoto parametru silně závisela na vstupních datech.

\subsection{Příkazová řádka}
Kompilace a spuštění programu v příkazové řádce se provede následující sekvencí příkazů:
\begin{verbatim}
	$ cd project
	$ make clean && make
	$ ./solver <input-graph> [seq|omp|mpi] [num_threads]
\end{verbatim}

\noindent Druhý parametr programu udává:
\begin{itemize}
	\item \textbf{seq} -- sekvenční běh.
	\item \textbf{omp} -- běh pouze v OpenMP (nepoužívají se volání MPI).
	\item \textbf{mpi} -- běh OpenMP + MPI (viz dále).
\end{itemize}

V případě použití parametrů \texttt{omp} nebo \texttt{mpi} je ještě nutné udat parametr \texttt{num\_threads}, který určuje, kolik vláken se má na každém výpočetním uzlu spustit.

\section{Popis paralelního algoritmu a jeho implementace v MPI}
Paralelní algoritmus v MPI umožňuje počítat distribuovaně na více výpočetních uzlech. Jedná se o algoritmus s distribuovanou pamětí -- každý z uzlů má svou vlastní a je třeba řešit jejich synchronizaci.

Výpočet maxima na každém z uzlů probíhá totožně jako v předchozím případě algoritmu OpenMP. Rozdíl je v tom kdy a s jakými parametry se tyto OpenMP výpočty spouštějí. To je řízeno komunikací uzlů v MPI. V této části popíšu způsob, jakým tato komunikace probíhá.

Obecný popis algoritmu je takový, že Master proces na začátku výpočtu vygeneruje počáteční stavy. Slave procesy si je od Mastera postupně odebírají a sami je u sebe řeší v OpenMP. Mastera notifikují o nově nalezených maximech a zároveň jsou od něj informováni o nových maximech, nalezených jinými Slavy. Master sám počítá, pokud nejsou žádné Slave procesy, které by potřebovaly novou práci.

\subsection{Master proces}
Master proces je proces s MPI rankem 0. Na začátku výpočtu standardním způsobem uvedeným výše vygeneruje počáteční grafy. Empiricky jsem jejich počet stanovil jako 80násobek počtu MPI procesů. V tuto chvíli Slave procesy nic nedělají. Po vygenerování stavů Master přejde do své výpočetní smyčky, která je zjednodušeně pseudokódem zapsána takto:

\begin{lstlisting}[tabsize=2,language=python]
while not done:
	if message_pending:
		if message_is(slave_needs_work):
			if initial_graphs.size() > 0:
				send_work(slave_id, initial_graphs.pop())
			else:
				send_no_more_work(slave_id)
				if all_slaves_received_no_more_work:
					done = true
					
		elif message_is(slave_finished_computing):
			candidate_graph = receive_result(slave_id)
			if candidate_graph > current_best:
				current_best = candidate_graph
				
	else:  # No pending messages -> start computing on Master node
		if initial_graphs.size() > 0:
			work_graph = initial_graphs.pop()
			computeOpenMP(work_graph, current_best)
\end{lstlisting}

Smyčka se ukončí, pokud byly všechny grafy zpracovány a všem Slave procesům odeslána zpráva \texttt{no\_more\_work}. Po jejím skončení je nalezeno nejlepší řešení, protože byl prohledán celý (ořezaný) stavový prostor.

\subsection{Slave proces}
Slave proces je komplementární k Masteru. Jeho výpočetní smyčka vypadá takto:
\begin{lstlisting}[tabsize=2,language=python]
while not done:
	work = request_work()
	if work is NO_MORE_WORK:
		break  # No more work to be done, quit loop
		
	my_best = computeOpenMP(work.graph, work.master_best)
	send_result(my_best)
\end{lstlisting}

Zde je smyčka jednodušší, Slave jen dokola žádá o práci a počítá. Spolu s prací Master vždy pošle i doposud nejlepší řešení, které si Slave uloží a použije pro ořezání stavového prostoru.

\subsection{Formát MPI zpráv}
Pro komunikaci v MPI používám hlavně jeden typ zprávy - Graf. Ta obsahuje zakódovaný objekt grafu a metadata. Kromě tohoto typu zprávy pak jen zprávy obsahující příznak (\texttt{tag}) -- to jsou zprávy žádosti o práci a oznámení o tom, že žádná práce již není k dispozici.

Formát zprávy s grafem má tento formát:
\begin{itemize}
	\item \texttt{int[5]}: \begin{enumerate}
		\item Počet hran nejlepšího zatím nalezeného řešení (používá se jen při zasílání grafu od Master pro Slave proces)
		\item Počet uzlů posílaného grafu
		\item \texttt{startI}
		\item \texttt{startJ}
		\item Počet hran posílaného grafu (šlo by spočítat z poslané matice, ale tímto se šetří výpočetní čas)
	\end{enumerate}

	\item \texttt{bool[n]}, kde \texttt{n} je počet uzlů grafu -- první řádek matice sousednosti 
	\item \texttt{bool[n]} -- druhý řádek matice sousednosti
	\item \texttt{...}
\end{itemize}

\subsection{Příkazová řádka}
Příkazy pro program jsou popsané v sekci výše. Pokud chci program spustit ve více procesech (pro MPI komunikaci), lze použít tuto konstrukci:
\begin{lstlisting}[tabsize=2]
	$ mpirun -n <process_count> ./solver input/graph mpi <threads_per_process>
\end{lstlisting}

\section{Namerene vysledky a vyhodnoceni}

\begin{enumerate}
\item Zvolte tri instance problemu s takovou velikosti vstupnich dat, pro ktere ma sekvencni 
algoritmus casovou slozitost kolem 5, 10 a 15 minut.
Pro mereni cas potrebny na cteni dat z disku a ulozeni na disk neuvazujte a zakomentujte
ladici tisky, logy, zpravy a vystupy.
\item Merte paralelni cas pri pouziti $i=2,\cdot,32$ procesoru na siti Ethernet.
%\item Pri mereni kazde instance problemu na dany pocet procesoru spoctete pro vas algoritmus dynamicke delby prace celkovy pocet odeslanych zadosti o praci, prumer na 1 procesor a jejich uspesnost.
%\item Mereni pro dany pocet procesoru a instanci problemu provedte 3x a pouzijte prumerne hodnoty.
\item Z namerenych dat sestavte grafy zrychleni $S(n,p)$. Zjistete, zda a za jakych podminek
doslo k superlinearnimu zrychleni a pokuste se je zduvodnit.
\item Vyhodnodte komunikacni slozitost dynamickeho vyvazovani zateze a posudte
vhodnost vami implementovaneho algoritmu pro hledani darce a deleni zasobniku pri reseni vaseho
problemu. Posudte efektivnost a skalovatelnost algoritmu. Popiste nedostatky
vasi implementace a navrhnete zlepseni.
\item Empiricky stanovte 
granularitu vasi implementace, tj., stupen paralelismu pro danou velikost reseneho
problemu. Stanovte kriteria pro stanoveni mezi, za kterymi jiz neni
ucinne rozkladat vypocet na mensi procesy, protoze by komunikacni
naklady prevazily urychleni paralelnim vypoctem.

\end{enumerate}

\section{Zaver}

Celkove zhodnoceni semestralni prace a zkusenosti ziskanych behem semestru.

\section{Literatura}

\appendix

\section{Navod pro vkladani grafu a obrazku do Texu}

Nejjednodussi zpusob vytvoreni obrazku je pouzit sunovsky graficky editor xfig,
ze ktrereho lze exportovat latex formaty (v poradi prosty latex, 
latex s macry epic, eepic, eepicemu) a postscript formaty,
uvedene poradi odpovida rustu komplikovanosti obrazku
(postscript umi jakykoliv obrazek, prosta latex macra pouze jednoduche,
epic makra neco mezi, je treba vyzkouset). Nasleduji priklady
pro vsechny pripady. 

Obrazek v postscriptu, vycentrovany a na celou sirku stranky, 
s popisem a cislem. Vsimnete si, jak ridit velikost obrazku.
%\begin{figure}[ht]
%\epsfysize=3cm
%\centerline{\epsfbox{VasObrazek.ps}}
%\caption{Popis vaseho obrazku}
%\label{labelvasehoobrazku}
%\end{figure}

%Obrazek pouze vlozeny mezi radky textu, bez popisu a cislovani.\\
%\epsfxsize=1cm
%\rule{0pt}{0pt}\hfill\epsfbox{VasObrazek.ps}\hfill\rule{0pt}{0pt}

%Texovske obrazky maji pripony *.latex, *.epic, *.eepic, a *.eepicemu, respective. 
%\begin{figure}[ht]
%\begin{center}
%\input VasObrazek.latex
%\end{center}
%\caption{Popis vaseho obrazku}
%\label{l1}
%\end{figure}
Vypustenim zavorek {\tt figure} dostanete opet pouze ramecek 
v textu bez cisla a popisu. 

%
%Takhle jednoduse muzete poskladat obrazky vedle sebe.
%\begin{center}
%\setlength{\unitlength}{0.1mm}\input VasObrazek.epic
%\hglue 5mm 
%\setlength{\unitlength}{0.15mm}\input VasObrazek.eepic
%\hglue 5mm 
%\setlength{\unitlength}{0.2mm}\input VasObrazek.eepicemu
%\end{center}
%Ridit velikost texovskych obrazku lze prikazem
%\begin{verbatim}
%\setlength{\unitlength}{0.1mm}
%\end{verbatim}
ktere meni meritko rastru obrazku, Tyto prikazy je ale soucasne 
nutne vyhodit ze souboru, ktery xfig vygeneroval.

Pro vytvareni grafu lze pouzit program gnuplot, ktery umi generovat postscriptovy soubor, ktery vlozite
do Texu vyse uvedenym zpusobem.

\end{document}